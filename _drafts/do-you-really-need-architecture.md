- Мой любимый вопрос - «Зачем?». Как думаешь, зачем нужна архитектура?
- Для быстрых прогнозируемых изменений кода? Ну не изменений, а добавления
нового поведения.
- Прогнозируемых = интуитивных? Если нет, то мне тогда нужна помощь, чтобы
понять ответ.
- Интуитивных? Даже не знаю. Одна из задач, чтоб сверху было примерно понятно
что происходит и чем занимается проект. Наверное, ответ - "Да".
- Ну скорее да чем нет, ага. Тогда каким будет самое важное ее качество?
- Ну я вижу самым главным качеством архитектуры - это возможность быстро
внедрить или изменить фичу для заказчика с минимальными изменениями
т.е. если мы строим какое-то здоровенное здание пользоваться которым будут
для работы, чтоб пожить, чтоб поиграть. Чтоб когда те, кто пришел к нам
поиграть, не захотели добавить футбольную площадку. И если в результате таких
изменений в переговорке стоят ворота, то значит архитектура не очень.
- :) Клевая метафора. А что в ней не очень? Цель достигнута и быстро
            (Сломалась вторая часть - интуитивность)
- В результате достижения цели для одного заказчика, мы, не намеренно, изменили
части другого заказчика. Это результат связывания.
- Это тоже, но если это обоих устроило то все ок )). Я считаю самым важным
качеством именно интуитивность
- Не, это не планируемые изменения
- Можно и так назвать. В общем про интуитивность. А что такое интуиция?
- Я считаю одной из главной вещей в архитектуре все же предсказуемость
- Ага. И мы выяснили ранее что это суть одно. Если хочешь, могу использовать
предсказуемость, но будет чуть дольше))
- Ты клонишь к тому, что слова собираются в образы, образы в классы, классы
в архитектуру и таким образом читая когда-то слова ты интуитивно чувствуешь код?
- Ну не совсем. А может и совсем Не. Интуиция это по сути опыт. Точнее решения,
принимаемые на его основе.
- Согласен
- Только вот нюанс: опыт разработки у всех разный, а нужно чтобы всем было
одинаково интуитивно. Что делать?
- Использовать один описанный :smile:
- Можно и так. Пробовал когда нибудь синхронизировать опыт с кем нибудь?
Например, убедить кондуктора что ты расплатишься в конце поездки. Или еще
какого-нибудь злобного упертого в том, что тебе можно доверять.
- Тяжело его синхронизировать если каждому пытаться угодить.
- Ага.
- А если один чувак говорит как надо и все делают.
-       (Есть другие варианты?) Чуваки меняются. Что делать когда он сменится?
- Другого взять). Власть меняется, векторы развития меняются. Это закон бытия.
- Перепишем архитектуру? Долго дорого. Бизнес финансировать не будет. А так как
принципы никто не знает - привет легаси и не интуитивный код.
Вспомни, что ты делаешь в приложении чтобы сохранить данные?
Denis Rudenko:fire: 8:31 PM
А почему ты решил что первая была не интуитивная?
Просто может новый человек по своему поймет ее
и так как интуитивность штука субъективная
Мы изначально получаем интуитивность одного !== интуитивности другого
А это прям указывает на проблему
Лучше тогда сказать, что архитектура должна следовать каким-то законам (edited)
Anton Marin 8:34 PM
Выносишь))
Вот и тут так же. Опыт нужно вынести в откзоустойчивое хранилище
Оу. Фига у меня связь пропала )))
Denis Rudenko:fire: 8:38 PM
))
Anton Marin 8:39 PM
А я не решал что она не была интуитивной. Более того, я от этого отталкивался. Дальнейшие события ты описал абсолютно верно.
А законы описать)) И возвращаемся к нашей первой попытке
Denis Rudenko:fire: 8:41 PM
Хорошо, тогда какие законы из твоего опыта должна содержать архитектура?
Anton Marin 8:41 PM
никаких)
вынести в откзоустойчивое хранилище
А что этим может быть в контексте опыта?
Подсказка: За что тебе платят?
Denis Rudenko:fire: 8:42 PM
за реализацию потребностей бизнеса :smile:
Anton Marin 8:44 PM
Ну почти ))
но это детали. Этого достаточно чтобы понять что есть наше хранилище
Denis Rudenko:fire: 8:45 PM
Нихрена не понимаю :smile:
Anton Marin 8:46 PM
Чтобы архитектура была интуитивна, ее следует строить от того как устроен бизнес
Если быть точнее, то коммуникации в бизнесе))
Закон Конвея. Но это детали
В такой ситуации архитектура станет не актуальной только тогда, когда сдохнет направление в бизнесе
Но если направление сдохло, то код становится не поддерживаемым или его можно выкинуть
Так вот к вопросу о компонентах
))
Denis Rudenko:fire: 8:49 PM
Это все хорошо, но не гарантирует главную потребность бизнеса - быстрое изменение системы
толку от единого языка
Anton Marin 8:49 PM
Компонент - самый верхний уровень в структуре нашего приложения. А раз структура идет от бизнеса, то возникает вопрос: А что у нас верхний уровень в бизнесе
Гарантирует
Ух
давно такие темы не обсуждал. зачерствел немного))
Если быть точным, это способствует отсутствию фрикций при загрузке контекста
потому как скорость изменений системы это не только разработка
Про контекст: Не задумывался из чего состоит решение проблемы?
Denis Rudenko:fire: 8:53 PM
Не, как-то слишком абстрактно
Anton Marin 8:59 PM
Тогда в этом вопросе не будем разгонять))
Мы сначала разбираем ее суть. Я это называю загрузкой контекста. Возможно и не я вовсе, а забыл откуда взял, но сути не меняет.
После того как мы осознаем проблему, мы переходим к проверке гипотезы. Здесь мы ищем предполагаем решение этой проблемы.
Затем этап дизайна. Накидываем решение
И под конец это пишем.
Кто то провел исследование. Толи Майкрософт, толи оракл эти обычно что то такое делают. И в итоге выяснили что среднее количество времени, которое уходит на загрузку контекста чет около 65%. При этом это средняя температура по палате. То есть в результатах есть как и приверженцы XP, так и проекты с огромным техдолгом.
Вот и получаем, что за счет крайне низкого времени загрузки контекста (здесь ответ на вопрос "а как это вообще сейчас работает") мы сильно бустим не только скорость, но и простоту решений
Denis Rudenko:fire: 9:05 PM
Хорошо, это понятно.
Но ведь не код может выступать как загрузка контектста
Лучше чтоб этим занимались тесты
Тогда мы можем единый язык перенести в тесты, когда код сделать более абстрактным
Anton Marin 9:06 PM
В теории да, но так ты все равно получишь слой "переводчик". Поговорил с бизнесом -> пошел переводить -> нашел в тестах -> пошел в код
А когда ты говоришь на одном языке, ты загружаешь контекст в процессе диалога
Denis Rudenko:fire: 9:07 PM
Да, но тогда людям, которые не впервые в проекте, и контекст проектной абстракции у него загружен, изменения в коде становятся значительно быстрее
Anton Marin 9:07 PM
это еще и целостность помогает сохранять
Покажи мне хоть одного человека, который знает контекст всего бизнеса начиная от среднего и держит его в голове и я поставлю тебе бутылку хорошего вискаря
Denis Rudenko:fire: 9:09 PM
Нет-нет. Бизнес у нас в тестах описан
но код у нас более абстрактный
Anton Marin 9:21 PM
)) ну хорошо
вот представь себе ситуацию
фраза бизнеса "Теперь Услуга не может быть оплачена без модерации" в каком классе этот функционал?
Denis Rudenko:fire: 9:23 PM
Теперь ты пишешь тест, который не пройдет это условие
Anton Marin 9:23 PM
Хотя похоже что очень простой вопрос))
Denis Rudenko:fire: 9:23 PM
и заставляешь его работать
Anton Marin 9:23 PM
)))))
Ага. И он заставляет тебя переписать 15 классов. Знакомо?
Denis Rudenko:fire: 9:26 PM
Вот это знакомо, когда у тебя код не соблюдает законы
Если мы представим, что у нас каждый класс имеют 1 причину для изменений, тогда такого кейса никогда не будет
Anton Marin 9:28 PM
Ага. Помнишь мой вопрос про "Refuser" ?
Denis Rudenko:fire: 9:28 PM
Reducer?
Anton Marin 9:28 PM
дадада точно
Denis Rudenko:fire: 9:28 PM
Угу, а какой вопрос?
Anton Marin 9:28 PM
почему так назвал
Denis Rudenko:fire: 9:29 PM
Так мы берем сейчас ситуацию, когда у нас есть тесты
Потому-что этот интерфейс создавался чтоб уменьшить кол-во коммуникаций
Anton Marin 9:30 PM
ну сути то не меняет. Тест тебе не даст интуитивного кода. Он только его зафиксирует и подскажет когда зависимость нужно выделять
А вот в какой тест посмотреть тебе что скажет?
Или будешь все 8000 тестов перечитывать?
Denis Rudenko:fire: 9:36 PM
В какой тест посмотреть, скажет ровно то, что сказало бы тебе, куда смотреть в коде
Anton Marin 9:37 PM
именно
поэтому не имеет смысла делать только одно
Denis Rudenko:fire: 9:39 PM
Нет, я тебе говорю, делая такими тесты, зачем копировать это в код?
Суть в чем.
С развитием кода, тесты становятся более специфичны, когда код более абстрактным
Абстрактным он как раз становится, чтоб поддерживать быстрые и контролируемые изменения
Anton Marin 9:40 PM
)) ну давай разгоним)) Про какие тесты мы говорим?
Anton Marin 10:10 PM
Все?
Denis Rudenko:fire: 10:17 PM
Сорян, отходил
Я понял, что одно другому не мешает
абстрактный код не означает отсутсвие UL
Anton Marin 10:18 PM
Это точно
Ну и «чистую выдумку» никто не отменял
