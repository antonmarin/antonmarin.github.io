---
header:
  image: /assets/images/falloutboy_thumbs_up_1280x360.jpg
permalink: /example-structure/
title: Пример структуры приложения
date: 03.02.2024
last_modified_at: 03.02.2024
share: true
---

# Вместо предисловия

Ниже опишу подход к структуре кода, который использую с 2020-го года. Подход не нов - он объединяет проектирование
по предметной области и использование слоев.

Ниже пример использования подхода - не стоит принимать его за фреймворк. В основе подхода - ряд принципов и целей,
а как их реализовать - выбор реализующего.
Из языков я чаще использую Kotlin, поэтому иногда будут появляться примеры свойственные ему, однако
такие примеры доступны и в других языках, возможно в немного другой форме.
В качестве примера использую серверное приложение - в нем больше сценариев использования, что позволяет
отразить больше примеров.

# TLDR

- `endpoints` # точки входа в приложение. Помогает соседнему разработчику найти как приложение использует данные, которые он ему поставляет
  - `http` # обработка http запросов. Группируем по акторам, чтобы избежать смешивания контрактов
    - `ControlPlaneController` # обработчики запросов от панели управления
      - `SomeRequest`, `SomeResponse`, `SomeError` различные DTO для принятия запроса
    - `StatsController` # обработчики запросов от отдела статистики
  - `consumer` # обработка асинхронных сообщений
  - `schedule` # обработка запросов из расписания или очереди
- `infrastructure` # фреймворк и реализации требований предметной области. Здесь прячем техническую сложность
  - `authentication` # разбор токена аутентификации в объект
  - `events` # система распространения предметных событий
    - `SimpleObserver : DomainEventObserver` # обозреватель событий запускает обработчики которые должны быть целостными с событием
    - `TransactionalOutbox` # контракт, целостно отправляет предметные события в интеграционные системы
  - `storage` # данные. Часто используются DataMapper или Repository
    - `http` # данные из внешних источников по http
    - `postgresql` # данные из postgresql
  - `schedule` # система обработки задач по расписанию или очереди
    - `ScheduleOutbox : TransactionalOutbox` # интеграция через систему расписаний. Используется для взаимодействия между контекстами
  - `messages` # транспорт через систему асинхронных сообщений, например Kafka
    - `KafkaOutbox : TransactionalOutbox` # интеграция через асинхронные сообщения. Используется для уведомления внешних систем
- `domain` # логика предметной области. В каждом приложении своя. Здесь используем единый с бизнесом язык
  - `showcase` # логика(контекст) витрины
    - `AddProductToCart` # сценарий добавления продукта в корзину. Хороший сценарий читается бизнес-аналитиком
      - `Request`,`Error` DTO для запуска сценария, может содержать только простейшие типы (скаляры, встроенные типы)
    - `contracts` # контракты систем, которые необходимы для выполнения бизнес процессов(кейсов/сценариев)
      - `ProductsStorage` # контракт хранилища товаров
      - `Order` # сущность заказа
  - `controlplane` # логика(контекст) панели управления
    - `authorization` # авторизация аутентифицированных пользователей
    - `contracts`
      - `Order` # тоже сущность заказа, но заказ для витрины отличается от заказа для панели управления
  - `events` # события которые жизненно важны бизнесу
    - `DomainEvent`, `DomainEventObserver`, `DomainEventProvider` контракты системы распространения предметных событий
    - `ProductAddedToCart`
    - `OrderConfirmed`
    - `OrderShipped`
- `Application` # запуск приложения

# Словарик

- Соседний - коллега, который не знаком с предметной областью или кодом приложения

# Что еще не решил

- Как соседнему разработчику узнать как именно формируются данные, которые он получает от приложения
