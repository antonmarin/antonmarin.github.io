---
header:
  image: /assets/images/falloutboy_thumbs_up_1280x360.jpg
permalink: /no-design/
title: Мои лучшие практики
excerpt: Что я считаю лучшими практиками и чего придерживаюсь.
date: 02.10.2018
last_modified_at: 17.03.2020
share: true
---
{{ page.excerpt }}

## В переговорке стоят ворота

- Мой любимый вопрос - «Зачем?». Как думаешь, зачем нужна архитектура?
- Для быстрых прогнозируемых изменений кода? Ну не изменений, а добавления
нового поведения.
- Прогнозируемых = интуитивных? Если нет, то мне тогда нужна помощь, чтобы
понять ответ.
- Интуитивных? Даже не знаю. Одна из задач, чтоб сверху было примерно понятно
что происходит и чем занимается проект. Наверное, ответ - "Да".
- Ну скорее да чем нет, ага. Тогда каким будет самое важное ее качество?
- Ну я вижу самым главным качеством архитектуры - это возможность быстро
внедрить или изменить фичу для заказчика с минимальными изменениями
т.е. если мы строим какое-то здоровенное здание пользоваться которым будут
для работы, чтоб пожить, чтоб поиграть. Чтоб когда те, кто пришел к нам
поиграть, не захотели добавить футбольную площадку. И если в результате таких
изменений в переговорке стоят ворота, то значит архитектура не очень.
- Клевая метафора. А что в такой архитектуре не очень? Цель ведь достигнута
и быстро.
- В результате достижения цели для одного заказчика, мы, не намеренно, изменили
части другого заказчика.
- Это тоже, но если это обоих устроило то все ок?. Кажется, это сломало
интуитивность.
- Похоже. Это не планируемые изменения.
- Можно и так назвать.
- Ок.
- В общем про интуитивность. А что такое интуиция?
- Я считаю одной из главной вещей в архитектуре все же предсказуемость.
- Ага. И мы выяснили ранее что это суть одно. Если хочешь, могу использовать
предсказуемость, но будет чуть дольше))
- Ты клонишь к тому, что слова собираются в образы, образы в классы, классы
в архитектуру и таким образом читая когда-то слова ты интуитивно чувствуешь код?
- Ну не совсем. А может и совсем Не. Интуиция это же по сути опыт. Точнее
решения, принимаемые на его основе.
- Согласен.
- Только вот нюанс: опыт разработки у всех разный, а нужно чтобы всем было
одинаково интуитивно. Что делать?

<!-- markdownlint-disable MD026 -->
## За что тебе платят?
<!-- markdownlint-enable MD026 -->

- Использовать один описанный!
- Можно и так. Пробовал когда-нибудь синхронизировать опыт с кем нибудь?
Например, убедить кондуктора что ты расплатишься в конце поездки. Или еще
какого-нибудь злобного упертого в том, что тебе можно доверять.
- Тяжело его синхронизировать если каждому пытаться угодить.
- Ага.
- А если один чувак говорит как надо и все делают?
- Чуваки меняются. Что делать когда он сменится?
- Другого взять! Власть меняется, векторы развития меняются. Это закон бытия.
- Перепишем архитектуру? Долго дорого. Бизнес финансировать не будет. А так как
принципы никто не знает - привет легаси и не интуитивный код. Ошибки, медленные
изменения.
- ...
- Вспомни, что ты делаешь в приложении, чтобы сохранить данные?
- Пишем в базу?
- Выносим в выделенное хранилище, ага. Что если поступить и тут так же? Вынести
опыт в отказоустойчивое хранилище.
- А почему ты решил что первая была не интуитивная? Просто может новый человек
по своему поймет ее и, так как интуитивность штука субъективная, мы изначально
получаем интуитивность одного !== интуитивности другого. А это прям указывает
на проблему. Лучше тогда сказать, что архитектура должна следовать каким-то
законам.
- А я и не решал. Более того, я как раз от обратного и отталкивался. Дальнейшие
события ты описал абсолютно верно. А законы прийдется описать, и вернуться
к нашей первой попытке. Продолжим?
- Хорошо, тогда какие законы из твоего опыта должна содержать архитектура?
- Никаких. "Выносим опыт в отказоустойчивое хранилище", помнишь?. А что может
быть таким хранилищем в контексте опыта?
- ...
- За что тебе платят?
- За реализацию потребностей бизнеса.
- Я бы назвал чуть иначе, но это детали. Этого достаточно, чтобы определить,
что есть наше хранилище.
- Ничего не понимаю.
- Архитектура не нужна если нет приложения, верно? Тогда когда наше приложение
потеряет актуальность?
- Когда бизнес сдохнет?
- А получается наш "опыт" теряет актуальность вместе с бизнесом. Так почему бы
не поместить архитектуру в него?
- ?...
- Есть такой Закон Конвея: "Организации, проектирующие системы, ограничены
дизайном, который копирует структуру коммуникации в этой организации"
(c) Wikipedia. Из него получаем что архитектура станет не актуальной только
тогда, когда сдохнет направление в бизнесе. Но если направление сдохло, то код
становится не поддерживаемым или его можно выкинуть. Вот это и позволяет
достичь Единый язык.
- Это все хорошо, но не гарантирует главную потребность бизнеса - быстрое
изменение системы.

## И он заставляет тебя переписать 15 классов

- Я бы сказал: гарантирует. Если быть точным, это способствует отсутствию
фрикций при загрузке контекста потому как скорость изменений системы это
не только код. Не задумывался из чего состоит решение какой-либо проблемы?
- Не, как-то слишком абстрактно.
- Тогда в этом вопросе не будем разгонять)) Мы сначала разбираем ее суть.
Здесь мы отвечаем на вопрос: "А как это вообще сейчас работает?". Я это называю
загрузкой контекста. Возможно и не я вовсе - забыл уже откуда
взял, но сути не меняет. После того как мы осознаем проблему, мы переходим
к проверке гипотезы. Здесь мы ищем предполагаем решение этой проблемы.
Затем этап дизайна, накидываем решение и под конец это пишем.
- ...
- Кто-то провел исследование. То ли Майкрософт, то ли Оракл, эти обычно что-то
такое делают. Выяснили что среднее количество времени, которое уходит
на "загрузку контекста" чет около 65%. При этом это средняя температура
по палате. То есть в результатах есть как приверженцы XP, так и проекты
с огромным техдолгом. Вот и получаем, что за счет крайне низкого времени
загрузки контекста мы сильно бустим не только скорость, но и простоту решений
- Хорошо, это понятно. Но ведь не только код может выступать как загрузка
контекста. Лучше чтоб этим занимались тесты. Тогда мы можем Единый язык
перенести в тесты, а код сделать более абстрактным.
- В теории да, но так мы получим слой "переводчик". Поговорил с бизнесом ->
пошел переводить -> нашел в тестах -> пошел в код. А когда ты
говоришь на одном языке - ты загружаешь контекст сразу в процессе диалога.
- Да, но тогда людям, которые не впервые в проекте, и контекст проектной
абстракции у него загружен, изменения в коде становятся значительно быстрее.
- Это еще и целостность помогает сохранять. Ты прав, но покажи мне хоть одного
человека, который знает контекст всего бизнеса, начиная от среднего размера, и
держит его в голове и я поставлю тебе бутылку хорошего вискаря на твой выбор.
- Нет-нет. Бизнес у нас в тестах описан. Но код у нас более абстрактный.
- Ну хорошо. Вот представь себе ситуацию: фраза бизнеса "Теперь Услуга не может
быть оплачена без модерации". В каком классе этот функционал?
- Теперь ты пишешь тест, который не пройдет это условие и заставляешь
его работать.
- Ага. И он заставляет тебя переписать 15 классов. Знакомо?
- Вот это знакомо, когда у тебя код не соблюдает законы. Если мы представим,
что у нас каждый класс имеют 1 причину для изменений, тогда такого кейса
никогда не будет.
- Вероятно. Помнишь мой вопрос про "Refuser" ?
- Reducer?
- дадада точно
- Угу, а какой вопрос?
- Почему так назвал?
- Так мы берем сейчас ситуацию, когда у нас есть тесты. Потому что этот
интерфейс создавался чтобы уменьшить кол-во коммуникаций
- Ну сути то не меняет. Тест тебе не даст интуитивного кода. Он только его
зафиксирует и подскажет когда зависимость нужно выделять. А вот в какой тест
посмотреть тебе что скажет? Или будешь все 8000 тестов перечитывать?
- В какой тест посмотреть, скажет ровно то, что сказало бы тебе, куда смотреть
в коде
- Именно поэтому не имеет смысла делать только одно.
- Нет, я тебе говорю, делая такими тесты, зачем копировать это в код? Суть
в чем. С развитием кода, тесты становятся более специфичны, когда код более
абстрактным. Абстрактным он как раз становится, чтобы поддерживать быстрые
и контролируемые изменения.
- Вероятно. Про какие тесты мы говорим? Все?
- Я понял! Одно другому не мешает. Абстрактный код не означает
отсутствие Единого языка.
- Ага. Ну и «чистую выдумку» никто не отменял.

...To be continued
